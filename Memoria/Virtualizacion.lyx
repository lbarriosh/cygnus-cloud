#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass memoir
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Virtualización
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
En este capítulo veremos como puede ser virtualizado un sistema, que alternativa
s hay y cuales han sido las seleccionadas para el proyecto.
 
\end_layout

\begin_layout Standard
La virtualización nos permite tener varios sistemas en la misma máquina,
 aislados unos de otros, y gracias a que esos sistemas pueden estar en un
 único archivo, podríamos cambiar alguno de ellos a otra máquina o hacer
 una copia de seguridad de forma rápida y sencilla, solo habría que copiar
 ese archivo al nuevo servidor o a un dispositivo de almacenamiento.
 Para conseguir esto, lo que tenemos es un hipervisor que nos permite gestionar
 esos recursos y asignarselos a las máquinas según los van necesitando.
 Este termino es un evolución de otro que se usa para referirse al 
\emph on
kernel
\emph default
 de los sistemas operativos, el supervisor.
 Esta gestión puede ser, en el caso de dispositivos de almacenamiento, la
 división de ese espacio según sea asignado por el usuario o, en el caso
 de dispositivos de tratamiento de dato como puede ser el procesador, asignadole
 un tiempo determinado de ejecución a cada sistema virtualizado.
\end_layout

\begin_layout Section
Historia
\end_layout

\begin_layout Standard
La virtualización, aunque pueda parecerlo, no es nueva, ya se usaba en la
 década de los 1960, antes incluso de los ordenadores personal.
 
\end_layout

\begin_layout Standard
IBM, en 1964, desarrolló un sistema operativo que gestionaba los recursos
 de
\emph on
 
\emph default
la máquina, llamado 
\emph on
VM
\emph default
 (
\emph on
Virtual Machine
\emph default
, Máquina Virtual), que permitía a varios usuarios usar una misma máquina
 a la vez, dando la apariencia de que eran ordenadores personales.
 Este desarrolló continuó en los dando soporte a los sistemas operativos
 que ya tenía IBM para que pudiesen ejecutarse sobre 
\emph on
VM
\emph default
, como son 
\emph on
PC/DOS
\emph default
, 
\emph on
MVS
\emph default
 y 
\emph on
DOS/VSE
\emph default
 e incluso el sistema 
\emph on
Unix.
\end_layout

\begin_layout Standard
A raíz de que se popularizó el uso de computadoras personales, en los años
 80s, la virtualización quedo relegada.
 Hasta que en 1999 VMware sacó el primer producto que permitía la virtualización
 sobre la arquitectura x86, la mas extendida en el mercado de los ordenadores
 personales.
 Luego, en 2003 se inició el proyecto de software libre Xen, en la universidad
 de Cambridge y en 2007 KVM, basado en el kernel de Linux para usarlo como
 hipervisor.
\end_layout

\begin_layout Standard
En 2005, la industria de los procesadores, sobre todo Intel y AMD, empezaron
 a desarrollar, independientemente, tecnologías en sus procesador que permitían
 una virtualización más sencilla y eficiente para los programas de virtualizació
n.
\end_layout

\begin_layout Section
Distintos esquemas de virtualización
\end_layout

\begin_layout Standard
El tipo de virtualización depende de como quién gestiona los recursos de
 la máquina y como se comunica el sistema virtualizado con esos recursos.
\end_layout

\begin_layout Subsection
Virtualización de hardware
\end_layout

\begin_layout Standard
En lo que se basa es en que sobre el hardware de la máquina se simula el
 hardware mediante máquinas virtuales, para luego poder ejecutar el sistema.
 El gran inconveniente de este esquema es que las instrucciones de la máquina
 virtualizada debe traducirse a instrucciones de la máquina 
\emph on
host
\emph default
, lo que requiere mucho tiempo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graficos/Virtualizacion/hardware.png
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Virtualización hardware
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Virtualización de software
\end_layout

\begin_layout Standard
En este esquema se utiliza un software para simular el ordenador, una máquina
 virtual, este debe ejecutarse sobre un sistema operativo concreto, que
 es el que tiene acceso al hardware y hace de intermediario entre este y
 la máquina virtual.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graficos/Virtualizacion/software.png
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Virtualización software
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este caso en el sistema guest, el hardware de almacenamiento, como puede
 ser el disco duro o las unidades ópticas, pueden ser virtuales o reales.
 Si son virtuales, es la máquina virtual la que se encarga de gestionarlo
 mediante archivos en el sistema 
\emph on
host
\emph default
, en el caso de que sean reales, la máquina virtual, en colaboración con
 el sistema host, le proporcionana al sistema virtualizado acceso a los
 mismos.
 El hardware que no sea posible virtualizar, como pueden ser una cámara
 o un micrófono, debe usar el hardware real, para ello la maquina virtual,
 transforma las llamadas del sistema 
\emph on
guest
\emph default
, en llamadas al sistema 
\emph on
host
\emph default
.
\end_layout

\begin_layout Standard
El mayor inconveniente de este esquema es que, como debe haber un sistema
 operativo ejecutándose, consumedo recursos de la máquina.
\end_layout

\begin_layout Subsection
Paravirtualización
\end_layout

\begin_layout Standard
En este esquema, al contrario que en el anterior, no es necesario de un
 sistema 
\emph on
host
\emph default
 para gestionar los recursos, sino que lo que se usa es una capa de virtualizaci
ón, también llamada hipervisor, que es la que gestiona los recursos.
 Pero no basta con eso, sino que debe haber una comunicación entre el sistema
 
\emph on
guest
\emph default
 y el hipervisor.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graficos/Virtualizacion/paravirtualizacion.png
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Paravirtualización
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esa comunicación se debe a que en los procesadores hay varios niveles de
 privilegios, llamados 
\emph on
ring
\emph default
, en concreto tienen 4 niveles, de ellos el 0 está reservado para el 
\emph on
kernel
\emph default
 del sistema operativo.
 Por lo que para que se pueda ejecutar el hipervisor, habría que modificar
 el kernel para que se ejecutase en el nivel 1 y dejar el 0 para el hipervisor.
 Esto no es ningún problema para sistemas operativos en los que el código
 fuente esté disponible y modificarlo, como pueden ser 
\emph on
Linux
\emph default
, pero en sistemas privativos como 
\emph on
Microsoft Windows
\emph default
 o 
\emph on
Mac OSX
\emph default
, no es posible hacer este cambio.
 
\end_layout

\begin_layout Standard
Aunque algunos programas de virtualización que esando esta técnica han conseguid
o ejecutar sistemas operativos sin modificar, para ello lo que hacen es,
 en tiempo de ejecución, detectar las instrucciones problemáticas, las que
 requieren de privilegios de nivel 0, y parchearlas, para que no haya problemas
 en el funcionamiento del sistema operativo, ni que el procesador se queje
 al intentar ejecutar una instrucción en un nivel inadecuado.
\end_layout

\begin_layout Subsection
Virtualización completa
\end_layout

\begin_layout Standard
Este esquema es parecido al anterior, también existe el hipervisor, pero
 al contrario que en la paravirtualización, no es necesaria una comunicación.
 Esto es porque en los procesadores que mayor cuota de mercado tiene (Intel
 y AMD) se ha añadido dos modos de ejecución, uno de ellos reservado para
 el hipervisor y el otro mantiene el uso que tenía, es decir, reservando
 el nivel 0 para el kernel, por ello no es necesario modificación alguna
 del sistema 
\emph on
guest
\emph default
.
 Estos modos son VMX para Intel 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
referencia: https://docs.google.com/viewer?a=v&q=cache:QyzbSEBX5oAJ:www.intel.com/de
sign/intarch/papers/316337.pdf+intel+non+root&hl=es&gl=es&pid=bl&srcid=ADGEEShEcj
1AHpkwlMee1bc1fVeScQvctJ3ctVojmlM3gSspHsPQW5CtRmcCWz89g6emcWDxqdZnJx0Z4vIlwOVUMa
Ng6gE8WOMCYV_bVlrunVO1KyRlN9LVqH_Ff4tFJ93_henKhbtt&sig=AHIEtbROTMAEF5Ebld_geP6r9
DR0Y3npCw
\end_layout

\end_inset

 y SVM para AMD
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
referencia: http://developer.amd.com/Resources/documentation/articles/Pages/122120
05112.aspx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graficos/Virtualizacion/completa.png
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Virtualización completa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Software de virtualización
\end_layout

\begin_layout Standard
Existen muchos programas de virtualización para todos los tipos como pueden
 ser VMware en sus distintas versiones, Xen, KVM, VirtualBox\SpecialChar \ldots{}
 Lo que buscamos
 en este proyecto es poder tener sistemas bajo demanda a bajo coste, por
 lo que nos centraremos en evaluar el software libre, 
\emph on
open source
\emph default
, 
\emph on
freeware
\emph default
, con lo queda descartado como opción VMware y aunque VirtualBox tiene una
 versión como software libre, algunas funciones como el soporte USB, está
 bajo una licencia propietario, por lo que también lo descartamos.
 
\end_layout

\begin_layout Standard
Aunque siguen existiendo muchas alternativas bajo las condiciones que queremos,
 nos centramos principalmente en Xen y KVM, por ser los que mayor trayectoria
 tienen.
 Debido a que Xen lleva mas años que KVM y estar apoyado por la comunidad,
 a parte de grandes empresas que apoyan el desarrollo como IBM, Intel, Red
 Hat u Oracle, es la mejor opción que podíamos escoger.
\end_layout

\begin_layout Section
Xen
\end_layout

\begin_layout Standard
Xen permite una virtualización de paravirtualización y virtualización completa
 en los procesadores que lo soporten.
\end_layout

\begin_layout Standard
Pero no todo en Xen son ventajas, ya que en el caso de que solo se pueda
 usar paravirtualización en una máquina solo podrán virtualizar los sistemas
 operativos que soporten el hipervisor de Xen.
 Además para que el usuario pueda interactuar con Xen debe ejecutar, sobre
 el hipervisor, un sistema operativo 
\emph on
guest
\emph default
 que tiene más privilegios que los demás sistemas que puedan ejecutarse
 sobre Xen.
\end_layout

\begin_layout Standard
Para saber como funciona Xen hay que como gestiona cada uno de los recursos.
 Eso es lo que vamos a ver a continuación:
\end_layout

\begin_layout Subsection

\series bold
Dom0, DomU.
\end_layout

\begin_layout Standard
El nombre con el que se denominan los sistemas guest en Xen es dominio (
\emph on
domain
\emph default
, en inglés).
 Existen dos tipos de dominios diferenciados, un es el 
\family typewriter
dom0
\family default
, que es el sistema privilegiado con el que se adminstra Xen y puede controlar
 los distintos dominios que se estén ejecutando, solo puede haber uno.
 El otro es el 
\family typewriter
domU
\family default
 es como se denomina a un sistema 
\emph on
guest
\emph default
.
 
\end_layout

\begin_layout Standard
El nombre de un dominio es como identifica Xen a cada uno de los sistemas,
 por lo que debe ser único.
 Puede modificarse en el archivo de configuración con el que se arranca
 el 
\emph on
guest.
\end_layout

\begin_layout Subsection
Interrupciones
\end_layout

\begin_layout Standard
Una interrupción se puede ver como una llama de atención del hardware e
 indica que ha ocurrido algo, un timer ha finalizado su cuenta, se ha pulsado
 un botón del raton\SpecialChar \ldots{}
 Aunque una interrupción requiere de una acción inmediata,
 lo que hace Xen es interceptarla y planificarla, asi cuando el 
\emph on
guest
\emph default
 vuelva a tener acceso al procesador la podrá tratar con el manejador correspond
iente.
 Este permite que cuando llega una interrupción, no haya que espera a que
 todos los 
\emph on
guest
\emph default
 la procesen, lo que sería muy costoso, por los cambios de dominios necesarios.
\end_layout

\begin_layout Subsection
CPU
\end_layout

\begin_layout Standard
La CPU es el recursos mas utilizado, ya que es el que ejecuta los programas.
 Xen trata a los distintos dominios como un sistema operativo trataría a
 los programas, es decir, tiene un planificador en el que a cada dominio
 les deja cierto tiempo para que puedan hacer sus calculos, también debe
 garantizar que a todos los dominios les deje usar la CPU.
\end_layout

\begin_layout Subsection
Memoria
\end_layout

\begin_layout Standard
El hipervisor, como gestor de los recursos de la máquina, tiene acceso a
 toda la memoria, la cual debe alojar toda la memoria usada por los distintos
 dominios, pero solo la memoria física y la tabla de página, ya que del
 resto, como la memoria virtual, se encarga cada domU.
 La memoria virtual permite que los procesos accedan a la memoria como si
 no hubiese nadie mas, es decir, acceso relativo, y luego se le suma la
 dirección donde empieza su espacio de memoria.
\end_layout

\begin_layout Standard
Como la asociación entre memoría física y virtual se hace atraves de las
 tablas de página, que son gestionadas por Xen, le permite tener un control
 de que dominio accede a que partes de la memoria, ya que puede denegar
 el acceso a una pagina si no le pertenece al dominio que se la ha pedido.
 Este permite aislamiento en la memoria, es decir, un dominio solo puede
 acceder a la memoría que le ha asignado Xen y le protege de que otro dominio
 modifique la memoria del primero.
\end_layout

\begin_layout Subsection
Dispositivos de entrada/salida
\end_layout

\begin_layout Standard
Ningún domU tiene gestión sobre los dispositivos, de esto se encarga el
 hipervisor con ayuda de dom0.
 Xen maneja los disposivos de E/S mediante dispositivos virtuales, que son
 enlaces entre las interfaces de los domUs y el dispositivo en el dom0.
 
\end_layout

\begin_layout Standard
El acceso a los dispositivos se hace mediante un buffer en anillo, así los
 dominios pueden acceder al dispositivo directamente sin intervención del
 hipervisor.
\end_layout

\begin_layout Subsection
Red
\end_layout

\begin_layout Standard
Como cualquier otro dispositivo, Xen proporciona una interfaz de red virtual
 a los dominios, además de algunas funciones para mover paquetes de la interfaz
 virtual del dominio a una interfaz virtual del dom0.
 El hipervisor en este caso solo mueve los datos de la interfaz física a
 la virtual, y de la virtual a la física cuando el dominio lo pida, pero
 no valida paquetes, eso lo manejan reglas en el dom0.
\end_layout

\begin_layout Subsection
Dispositivos de bloque
\end_layout

\begin_layout Standard
Son dispositivos de almacenamiento en los que solo se puede leer y escribir
 en bloques de bytes, el tamaño del bloque depende del dispositivo y su
 configuración, estos pueden discos duros, CD-ROMs o memorias USB.
\end_layout

\begin_layout Standard
Xen gestiona los dispositivos de bloque casi como los dispotivos de red.
 El hipervisor exporta el dispositivo virtual de bloques al domU y proporciona
 al dom0 la capacidad de mapear la funcionalidad del dispositivo real en
 el virtual.
\end_layout

\begin_layout Section
KVM
\end_layout

\begin_layout Standard
Kvm(Kernel-based Virtual Machine) es una aplicación de virtualización sobre
 sistemas linux x86 que ha experimentado un rapido crecimiento.
 Se compone de un módulo de kernel que proporciona la infraestructura de
 virtualización de núcleo y un módulo de procesador específico.
 
\end_layout

\begin_layout Standard
En realidad, el termino más acertado sobre KVM se refiere al nivel del kernel
 donde se aloja la funcionalidad de virtualización, pero en la práctica
 es más utilizado para hacer referencia al componente en el que trabaja
 el usuario.
\end_layout

\begin_layout Standard
Usando KVM, se puede ejecutar múltiples máquinas virtuales sin necesidad
 de modificar las imagenes de linux o de windows.
 Cada máquina virtual tiene su propio hardware de virtualización privado
 : su propia tarjeta de red, su disco, su tarjeta gráfica etc.
\end_layout

\begin_layout Standard
El componente KVM para el kernel viene incluido en linux desde la versión
 2.6.20.
 Así kvm convierte el kernel de linux en un hipervisor.
 Como el kernel estandar de linux es un hipervisor, todos los componentes
 que lo forman se encuentra beneficiados por todas las ventajas de la virtualiza
ción.
 Las optimizaciones de estos componentes benefician tanto al hipervisor
 del kernel (el sistema operaaivo del host) como a los diferentes huespedes.
 Como el kernel se ejecuta como un hipervisor, es posible arrancar otros
 sistemas operativos tanto en linux como en windows.
\end_layout

\begin_layout Standard
Las máquinas virtuales, así como su almacenamiento y redes virtuales pueden
 ser dirigidas por parte de libvirt y de la herramienta QEMU.
 Libvirt es una librería que proporciona una API a los usuarios para dirigir
 sus máquinas virtuales, basadas en diferentes soluciones de virtualización,
 tales como KVM y Xen.
 Esta cuenta tanto con una interfaz gráfica de usuario, como con una herramienta
 para linea de comandos.
\end_layout

\begin_layout Standard
Actualmente existen muchos sistemas de virtualización tales como Xen, Bochs,
 UML, Linux VServer, y coLinux, sin embargo, kvm está adquiriendo una mayor
 presencia en el mercado.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Tengo que reorganizar esta información.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Requisitos Hardware
\end_layout

\begin_layout Standard
KVM está diseñado en torno a las características de virtualización de hardware
 incluidas en los ordenadores AMD (AMD-V) e Intel (VT-x).
 Es compatible con funciones de virtualización de chipsets y dispositivos
 PCI, como la E/S de la unidad de memoria (IOMMU) y la la E/S del sistema
 simple de virtualización root (SR-IOV)).
\end_layout

\begin_layout Standard
Por ello KVM no podrá ejecutarse si el ordenador no puede soportar la virtualiza
ción hardware o si la misma no se encuentra activada en la bios.
\end_layout

\begin_layout Standard
En cuanto al rendimiento, es necesario tener en cuenta que el servidor deberá
 ser capaz de afrontar el incremento de memoria RAM que supone la conexión
 de cada huesped, y tener al menos un nucleo del procesador o un hilo para
 cada huesped.
\end_layout

\begin_layout Subsection
El paquete KVM
\end_layout

\begin_layout Standard
El paquete de KVM contiene el programa qemu-kvm, el cual se encarga de realizar
 la emulación.
 
\end_layout

\begin_layout Standard
Además de este programa el paquete también incluye una utilidad de monitorizació
n a nivel de depuración(kvm-sat), componentes de firmware, archivos de correlaci
ón de teclas, scripts y algunos drivers para realizar la paravirtualización
 en windows, aunque se desaconseja el uso de estos últimos por estar bastante
 desactualizados.
\end_layout

\begin_layout Standard
Originariamente, el paquete de kvm también contaba con los módulos del kernel
 de kvm.
 Sin embargo, en la actuaalidad estos módulos se encuentran ya incluidos
 en el kernel y el paquete solo proporciona los componentes de usuario.
\end_layout

\begin_layout Standard
Además de las herramientas incluidas en el paquete de kvm es recomendable
 la instalación y uso de otras herramientas secundarias que facilitan la
 gestión del sistema.
 Todas estas herramientas son proporcionadas por los paquetes que llevan
 su nombre.
 Algunos de estos paquetes son:
\end_layout

\begin_layout Itemize
Libvirt: este paquete incluye la herramienta libvirt que permite creación,
 eliminación y gestión en general de las diferentes maquinas virtuales.
 Además en este paquete también se incluyen herramientas de gestión de redes
 virtuales y almacenamiento.
\end_layout

\begin_layout Itemize
Virt-manager (Virtual Machine Manager): Incluye una herramienta gráfica
 de administración de los huespedes de las máquinas virtuales.
\end_layout

\begin_layout Itemize
Vm-install: configura una nueva maquina virtual e instala un sistema operativo
 en la misma.
\end_layout

\begin_layout Itemize
Virt-viewer: Incluye una herramienta que permite interactuar con la virtualizaci
ón de un determinado huesped.
 Utiliza libvirt y pretende ser un reemplazo para los clientes de VNC y
 SPICE.
\end_layout

\begin_layout Subsection
Ventajas de KVM
\end_layout

\begin_layout Standard
La virtualización con kvm ofrece las siguientes ventajas:
\end_layout

\begin_layout Itemize
Esta diseñado para procesadores x86, centrando en un virtualizacion total.
\end_layout

\begin_layout Itemize
No se modifica el kernel de GNU/Linux.
\end_layout

\begin_layout Itemize
Está basado en un módulo que no necesita ninguna clase de parches.
\end_layout

\begin_layout Itemize
Contiene soporte para la paravirtualización.
\end_layout

\begin_layout Itemize
Funciona en todo tipo de maquinas, servidores, escritorios o laptop.
\end_layout

\begin_layout Itemize
Permite una migración en caliente de las maquinas virtuales.
\end_layout

\begin_layout Itemize
Permite una administración vía web, gráfica y consola.
\end_layout

\begin_layout Itemize
Las máquinas serán reconocidas como procesos, facilitándose así la administració
n de las mismas.
\end_layout

\begin_layout Itemize
Maneja 3 tipos de configuración de red, Bridge, Route y NAT.
\end_layout

\begin_layout Itemize
Permite ejecutar multiples máquinas virtuales, cada una con su propia instancia.
\end_layout

\begin_layout Subsection
Limitaciones de KVM
\end_layout

\begin_layout Standard
Aunque las maquinas virtuales se comportan casi como máquinas físicas existen
 ciertas limitaciones.
 Estas limitaciones afectan tanto al huesped alojado en la maquina virtual
 como al servidor que la gestiona.
 Las principales limitaciones que podemos encontrar en la virtualización
 con Kvm son:
\end_layout

\begin_layout Itemize
OverCommits : Kvm permite un overcommit tanto en la memoria como en el espacio
 de disco.
 Esto permite aumentar el número de usuarios conectados a un determinado
 servidor.
 Sin embargo, esto también provoca errores permanentes que pueden acarrear
 fallos en la conexión de los huespedes.
 También es posible un overcommit en la CPU, lo cual provoca un empeoramiento
 del rendimiento.
\end_layout

\begin_layout Itemize
Tiempo de sincronización : Generalmente los usuarios requieren de un soporte
 adicional para poder utilizar de manera adecuada el tiempo de sincronización.
 Este soporte adicional puede comportarse de manera contraproducente y empeorar
 el rendimiento.
\end_layout

\begin_layout Itemize
Direcciones MAC : Si no existe una dirección mac asociada a una tarjeta
 de red, kvm asignará una por defecto.
 Esto puede dar lugar a problemas en la red cuando más de una tarjeta de
 red recibe la misma dirección MAC.
 Se recomienda usar siempre una dirección Mac única.
\end_layout

\begin_layout Itemize
Migración en vivo : La migración en vivo es sólo posible entre los servidores
 host de VM con la misma CPU.
 El almacenamiento de la información de un usuario debe ser accesible desde
 los diferentes servidores, se encuentren o no en la misma CPU.
 
\end_layout

\begin_layout Itemize
Permisos de usuario : Las diferentes herramientas de gestión deben ser autentica
das por libvirt.
 Por ello para que un usuario pueda invocar a qemu-kvm desde linea de comandos,
 el usuario debe ser miembro del grupo de kvm.
\end_layout

\begin_layout Itemize
Suspensión e hibernación del servidor de maquinas virtuales : No se permite
 la posibilidad de suspender o hibernar el servidor mientras existan usuarios
 conectados al mismo.
\end_layout

\begin_layout Subsection
Red en KVM
\end_layout

\begin_layout Standard
Como ya mencionamos en las ventajas, Kvm dispone de tres tipos de configuración
 de red :
\end_layout

\begin_layout Itemize
Bridge : Este tipo de configuración permite crear un puente entre las tarjeta
 de red física y las virtuales, permitiendo al usuario conectarse a la red
 remota como si fueran otras máquinas que estuvieran en la red local.
 Es el más recomendado.
\end_layout

\begin_layout Itemize
NAT : Este tipo de configuración permite tener máquinas virtuales dentro
 de una red virtual, configurando de manera especial su conexión a la tarjeta
 de red, lo cual ayuda a tener una mayor seguridad en las maquinas virtuales.
 
\end_layout

\begin_layout Itemize
Route 
\begin_inset Note Note
status open

\begin_layout Plain Layout
No he encontrado una definición sobre en que consiste este tipo de configuración.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
